<h1>Тема урока: словари в Python</h1>

<ol>
	<li>Новый тип коллекции</li>
	<li>Отличия словарей от списков</li>
	<li>Создание словарей</li>
	<li>Обращение по ключу</li>
	<li>Встроенная функция <code>dict()</code></li>
	<li>Создание словарей на основе списков и кортежей</li>
	<li>Пустой словарь</li>
	<li>Вывод словаря</li>
	<li>Особенности словарей</li>
</ol>

<p><strong>Аннотация.</strong> В этом уроке мы начнем изучение словарей в Python, тип данных – <code>dict</code>. Этот тип данных похож на списки и применяется при решении многих задач.</p>

<h2 style="text-align: center;">Словари</h2>

<p>В прошлых уроках мы изучили четыре типа коллекций в Python:</p>

<ul>
	<li>списки – изменяемые коллекции элементов, индексируемые;</li>
	<li>строки – неизменяемые коллекции символов, индексируемые;</li>
	<li>кортежи – неизменяемые коллекции элементов, индексируемые;</li>
	<li>множества – изменяемые коллекции уникальных элементов, неиндексируемые.</li>
</ul>

<p>Следующий тип – <strong>словари</strong> – изменяемые коллекции элементов <strong>с произвольными индексами – ключами</strong>. Если в списках элементы индексируются целыми числами, начиная с <code>0</code>, то в словарях — любыми ключами, в том числе в виде строк.</p>

<p>Как нам уже известно, списки — удобный и самый популярный способ хранения большого количества данных в одной переменной. Списки индексируют все хранящиеся в них элементы, что позволяет быстро обращаться к элементу, зная его индекс. </p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">languages = ['Python', 'C#', 'Java', 'C++']

print(languages[0])
print(languages[2])
</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Python
Java</code></pre>

<p>Допустим, мы хотим хранить имя создателя каждого языка программирования. Это можно сделать несколькими способами.</p>

<p><strong>Способ 1.</strong> Хранить еще один список, где по соответствующему индексу будет находиться имя создателя языка программирования.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">languages = ['Python', 'C#', 'Java', 'C++']
creators = ['Гвидо ван Россум', 'Андерс Хейлсберг', 'Джеймс Гослинг', 'Бьёрн Страуструп']

print('Создателем языка', languages[0], 'является', creators[0])</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Создателем языка Python является Гвидо ван Россум</code></pre>

<p>Подход рабочий, но хранить данные в двух коллекциях не очень удобно.</p>

<p><strong>Способ 2.</strong> Хранить список кортежей с парами значений "язык - имя создателя" в каждом.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">languages = [('Python', 'Гвидо ван Россум'), 
             ('C#', 'Андерс Хейлсберг'), 
             ('Java', 'Джеймс Гослинг'), 
             ('C++', 'Бьёрн Страуструп')]

print('Создателем языка', languages[2][0], 'является', languages[2][1])</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Создателем языка Java является Джеймс Гослинг</code></pre>

<p>Тоже рабочий подход, однако не очень эффективный. Придется написать цикл <code>for</code> для поиска по всем элементам списка <code>languages</code> кортежа, первый элемент которого равен искомому (названию языка). Чтобы найти автора языка C++ , нужно будет в цикле пройти мимо Python, C# и Java. Угадать заранее, что язык C++ лежит после них, не получится.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">languages = [('Python', 'Гвидо ван Россум'), 
             ('C#', 'Андерс Хейлсберг'), 
             ('Java', 'Джеймс Гослинг'), 
             ('C++', 'Бьёрн Страуструп')]

for item in languages:
    if item[0] == 'C++':
        print('Создателем языка', item[0], 'является', item[1])</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Создателем языка C++ является Бьёрн Страуструп</code></pre>

<p>Списки индексируются целыми числами, но в этом случае удобно было бы находить информацию не по числу, а по строке — названию языка программирования. В списках строки не могут быть индексами, однако в словарях это возможно.</p>

<p>Словарь (тип данных <code>dict</code>), как и список, позволяет хранить много данных. В отличие от списка, в словаре для каждого элемента можно произвольно определить «индекс» — <strong>ключ</strong>, по которому он будет доступен. </p>

<p><img alt="" height="49" src="https://ucarecdn.com/6b8c5b11-398e-4d4a-b30f-19faa1a817bf/" style="float: left;" width="49">Словарь — реализация структуры данных "ассоциативный массив" или "хеш таблица". В других языках аналогичная структура называется <code>map, HashMap, Dictionary</code>.</p>

<h3 style="text-align: center;">Создание словаря</h3>

<p>Чтобы создать словарь, нужно перечислить его элементы, пары ключ—значение, через запятую в фигурных скобках, как и элементы множества. Первым указывается ключ, после двоеточия — значение, доступное в словаре по этому ключу.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}</code></pre>

<p>создает словарь, в котором ключом служит строка — название языка программирования, а значением — имя создателя языка.</p>

<h3 style="text-align: center;">Обращение к элементу словаря</h3>

<p>Извлечь значение элемента словаря можно обратившись к нему по его ключу. Чтобы получить значение по заданному ключу, как и в списках, используем квадратные скобки <code>[]</code> , индексируем по ключу.</p>

<p><strong>Способ 3. </strong>Приведенный ниже код:</p>

<pre><code class="language-python">languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C#'])</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Создателем языка C# является Андерс Хейлсберг</code></pre>

<p>В отличие от списков, номеров позиций в словарях нет.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages[1])</code></pre>

<p>приводит к возникновению ошибки <code>KeyError</code>.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/59df7155-e313-42ae-98ff-db8ba0e8910b/" style="float: left;" width="49">Ошибка <code>KeyError</code> возникнет и при попытке извлечь значение по несуществующему ключу. В качестве ключа можно указать выражение, Python вычислит его значение, и обратится к искомому элементу.</p>

<p><strong>Способ 4. </strong>Приведенный ниже код:</p>

<pre><code class="language-python">languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг', 
             'C++': 'Бьёрн Страуструп'}

print('Создателем языка C# является', languages['C' + '#'])</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Создателем языка C# является Андерс Хейлсберг</code></pre>

<h3 style="text-align: center;">Создание словаря с помощью функции dict()</h3>

<p>Если ключи словаря — строки, без каких-либо специальных символов, то для создания словаря можно использовать функцию <code>dict()</code> .</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">info = dict(name = 'Timur', age = 28, job = 'Teacher')</code></pre>

<p>создает словарь с тремя элементами, ключами которого служат строки <code>'name', 'age', 'job'</code>, а значениями: <code>'Timur', 28, 'Teacher'</code>.</p>

<h3 style="text-align: center;">Создание словаря на основании списков и кортежей</h3>

<p>Создавать словари можно на основе списков кортежей или кортежей списков. Первый элемент списка или кортежа станет ключом, второй — значением.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">info_list = [('name', 'Timur'), ('age', 28), ('job', 'Teacher')]  # список кортежей

info_dict = dict(info_list)  # создаем словарь на основе списка кортежей</code></pre>

<p>создает словарь с тремя элементами, где ключи — строки <code>name, age, job</code>, а соответствующие им значения — <code>'Timur', 28, 'Teacher'</code>.</p>

<p>Аналогично работает приведенный ниже код: </p>

<pre><code class="language-python">info_tuple = (['name', 'Timur'], ['age', 28], ['job', 'Teacher'])  # кортеж списков

info_dict = dict(info_tuple)  # создаем словарь на основе кортежа списков</code></pre>

<p>Если необходимо создать словарь, каждому ключу которого соответствует одно и то же значение, можно воспользоваться методом <code>fromkeys()</code>.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">dict1 = dict.fromkeys(['name', 'age', 'job'], 'Missed information')</code></pre>

<p>создает словарь с тремя элементами, где ключи — строки <code>'name', 'age', 'job'</code>, а соответствующие им значения: <code>'Missed information', 'Missed information', 'Missed information'</code>.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/11fe44c0-82d2-4647-a5ef-86327c0370c1/" width="49">   Если методу <code>fromkeys()</code> не передать второй параметр, то по умолчанию присваивается значение <code>None</code>.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">dict1 = dict.fromkeys(['name', 'age', 'job'])</code></pre>

<p>создает словарь с тремя элементами, в которых ключи — строки <code>'name', 'age', 'job'</code>, а значения — <code>None, None, None</code>.</p>

<h3 style="text-align: center;">Пустой словарь</h3>

<p><strong>Пустой словарь</strong> можно создать двумя способами:</p>

<ul>
	<li>с помощью пустых фигурных скобок;</li>
	<li>с помощью функции <code>dict()</code>.</li>
</ul>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">dict1 = {}
dict2 = dict()


print(dict1)
print(dict2)
print(type(dict1))
print(type(dict2))</code></pre>

<p>создает два пустых словаря и выводит:</p>

<pre><code class="language-1c">{}
{}
&lt;class 'dict'&gt;
&lt;class 'dict'&gt;</code></pre>

<p><img alt="" height="49" src="https://ucarecdn.com/a4bdf6e5-7adb-426a-a3fb-9dd1ae177992/" style="float: left;" width="49">Вспомните, что создать пустое множество можно, только используя функцию <code>set()</code> , потому что пустые фигурные скобки зарезервированы для создания словаря.</p>

<h3 style="text-align: center;">Вывод словаря</h3>

<p>Для вывода всего словаря можно использовать функцию <code>print()</code>:</p>

<pre><code class="language-python">languages = {'Python': 'Гвидо ван Россум', 
             'C#': 'Андерс Хейлсберг', 
             'Java': 'Джеймс Гослинг'}

info = dict(name = 'Timur', age = 28, job = 'Teacher')

print(languages)
print(info)</code></pre>

<p>Функция <code>print()</code> выводит на экран элементы словаря, в фигурных скобках, разделенные запятыми:</p>

<pre><code>{'Python': 'Гвидо ван Россум', 'C#': 'Андерс Хейлсберг', 'Java': 'Джеймс Гослинг'}
{'name': 'Timur', 'age': 28, 'job': 'Teacher'}</code></pre>

<p><img alt="" height="49" src="https://ucarecdn.com/10a6cd44-9b40-4a15-b44b-eabb13a20a78/" style="float: left;" width="49">Начиная с версии Python 3.6 словари являются упорядоченными, то есть сохраняют порядок следования ключей в порядке их внесения в словарь.</p>

<h2 style="text-align: center;">Примечания</h2>

<p><strong>Примечание 1. </strong>Словари принципиально отличаются от списков по структуре хранения в памяти. Список — последовательная область памяти, то есть все его элементы (указатели на элементы) действительно хранятся в указанном порядке, расположены последовательно. Благодаря этому и можно быстро «прыгнуть» к элементу по его индексу. В словаре же используется специальная структура данных — <strong>хеш-таблица</strong>. Она позволяет вычислять числовой хеш от ключа и использовать обычные списки, где в качестве индекса элемента берется этот хеш.</p>

<p><strong>Примечание 2.</strong> В рамках одного словаря каждый ключ уникален.</p>

<p><strong>Примечание 3.</strong> Словари удобно использовать для хранения различных сущностей. Например, если нужно работать с информацией о человеке, то можно хранить все необходимые сведения, включающие такие разные сущности как "возраст", "профессия", "название города", "адрес электронной почты" в одном словаре  <code>info</code> и легко обращаться к его элементам по ключам:</p>

<pre><code class="language-python">info = {'name': 'Timur',
        'age': 28,
        'job': 'Teacher',
        'city': 'Moscow',
        'email': 'timyr-guev@yandex.ru'}

print(info['name'])
print(info['email'])</code></pre>

<p style="text-align: center;"><img alt="" height="258" src="https://ucarecdn.com/6868ea52-8412-4284-a63e-8e1a388a40ec/" width="540"></p>

<p><strong>Примечание 4.</strong> Создать словарь на основании двух списков (кортежей) можно с помощью встроенной функции-упаковщика <code>zip()</code>, о которой расскажем позже.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">keys = ['name', 'age', 'job']
values = ['Timur', 28, 'Teacher']

info = dict(zip(keys, values))

print(info)</code></pre>

<p>выводит (порядок элементов может отличаться):</p>

<pre><code>{'name': 'Timur', 'age': 28, 'job': 'Teacher'}</code></pre>

<p><img alt="" height="49" src="https://ucarecdn.com/f5637d49-170c-46e1-ba4a-f32d338eae14/" width="49">   В случае несовпадения длины списков, функция самостоятельно отсечет лишние элементы.</p>

<h2 style="text-align: right;"><strong>Made with 💛 by BEEGEEK</strong></h2>