<h1>Тема урока: работа с текстовыми файлами</h1>

<ol>
	<li>Позиция (курсор) в файле</li>
	<li>Менеджеры контекста</li>
</ol>

<p><strong>Аннотация.</strong> Урок посвящен работе с файлами: позиция считывания в файле, методы <code>seek(), tell()</code>, а также работа с менеджером контекста.</p>

<h2 style="text-align: center;">Позиция в файле</h2>

<p>Когда мы читаем текст из файла с помощью методов <code>read()</code> или <code>readlines()</code> происходит перемещение <strong>текущей позиции</strong> в конец файла. При использовании метода <code>readline()</code> текущая позиция перемещается на следующую строку файла.</p>

<p>При открытии файла текущая позиция всегда равна нулю – указывает на первый символ текста. При прочтении файла до конца с помощью вызова методов <code>read(), readlines()</code> позиция перемещается в конец файла и последующие чтения ничего не дают.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/4b9c38db-3df1-4af7-a7f6-1a51bc5a1f41/" style="float: left;" width="49">Вызов методов <code>read(), readlines(), readline()</code> перемещает текущую позицию туда, где завершилось чтение. Для методов <code>read()</code> и <code>readlines()</code> это конец файла, для метода <code>readline()</code> – следующая строка после прочитанной.</p>

<p>Текущую позицию обычно называют "<strong>курсор"</strong>. </p>

<p>Предположим, у нас есть файл <code>languages.txt</code>. Когда мы его открываем, курсор находится в начале файла, в нулевой позиции, это выглядит примерно так:</p>

<p style="text-align: center;"><img alt="" height="404" src="https://ucarecdn.com/448f886e-cc06-470f-9cd5-6ba571341214/" width="554"></p>

<p>Если мы считаем две строки с помощью метода <code>readline()</code>:</p>

<pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
line2 = file.readline()

file.close()</code></pre>

<p>курсор переместится в начало третьей строки:</p>

<p style="text-align: center;"><img alt="" height="404" src="https://ucarecdn.com/b0362a51-bf99-469c-b306-8a831479b1e0/" width="551"></p>

<p>Чтение всегда происходит слева направо от курсора. Таким образом, если после двух вызовов метода <code>readline()</code> вызвать метод <code>read()</code>, он считает не весь файл, а только оставшиеся строки:</p>

<pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
line2 = file.readline()
remaining_lines = file.read()    # считывание начинается с 3 строки до конца файла

file.close()</code></pre>

<p>После того, как мы считали все строки файла, курсор находится в конце.</p>

<p style="text-align: center;"><img alt="" height="404" src="https://ucarecdn.com/95f1fee4-011b-4286-a5c7-62dddab0e54c/" width="549"></p>

<p>После завершения чтения мы больше не можем считать ни одного символа из файла. Все последующие вызовы методов <code>read()</code> или <code>readline()</code> будут приводить к считыванию пустой строки.</p>

<p>Для повторного чтения данных из файла, можно:</p>

<ul>
	<li>переоткрыть файл, тогда курсор снова попадёт в начало;</li>
	<li>переместить курсор с помощью файлового метода <code>seek()</code>.</li>
</ul>

<h3 style="text-align: center;">Файловый метод seek()</h3>

<p>Файловый метод <code>seek()</code> задаёт позицию курсора в байтах от начала файла. Чтобы перевести курсор в самое начало файла необходимо вызвать метод <code>seek()</code>, передав ему в качестве аргумента значение $0$.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
line1 = file.readline()
file.seek(0)               # переводим курсор в самое начало
line2 = file.readline()

print(line1, line2)

file.close()</code></pre>

<p>выводит:</p>

<pre><code>Python
Python</code></pre>

<p>Метод <code>seek()</code> <strong>не очень</strong> полезен при работе с текстовыми файлами, так как не учитывает разделение текста на строки. А вот при работе с файлами в двоичном режиме умение работать с позицией и смещениями очень важно!</p>

<p><img alt="" height="49" src="https://ucarecdn.com/0c41708b-8782-49e0-ac25-61a21948c9d8/" style="float: left;" width="49">Будьте аккуратны с символами, использующими более $1$ байта (кириллица в кодировке <code>utf-8</code>), обращение к "промежуточному" байту может вызвать ошибку.</p>

<p>Если метод <code>seek()</code> устанавливает курсор (текущую позицию), то метод <code>tell()</code> получает ее.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')
print(file.tell())
line1 = file.readline()
print(file.tell())

file.close()</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">0
8</code></pre>

<p>В самом начале курсор (текущая позиция) равен нулю, после считывания первой строки, курсор смещается на $8$ байт (по байту на каждый из символов <code>'P', 'y', 't', 'h', 'o', 'n'</code> и два байта на символ перевода строки <code>'\n'</code>).</p>

<h2 style="text-align: center;">Менеджер контекста</h2>

<p>Как уже сказано, важно своевременно закрывать файлы с помощью метода <code>close()</code>. Закрытие файлов вручную, а также отдача закрытия на откуп среде исполнения, обладают существенным недостатком: если между открытием файла и его закрытием произойдёт ошибка, в лучшем случае файл окажется открыт слишком долго, а в худшем случае часть данных не сохранится.</p>

<p>Хочется иметь возможность автоматически закрывать файл сразу после окончания работы с ним и осуществлять закрытие даже при возникновении ошибки. Файловые объекты уже умеют работать в таком режиме, но для этого их нужно использовать как <strong>менеджеры контекста</strong>.</p>

<p>Менеджер контекста<em> </em>— объект, реализующий одноименный протокол. Объекты, реализующие этот протокол, позволяют использовать следующий специальный синтаксис:</p>

<pre><code class="language-python">with object as name:
    # Здесь нам доступен ресурс name.
    # Это тело with-блока.
# А здесь ресурс name уже освобождён, даже если в теле with-блока произошла ошибка.
</code></pre>

<p>Весь код в теле <code>with</code>-блока работает "в контексте". Чаще всего контекст подразумевает выделение некоего ресурса, например, файла. По выходу из контекста ресурс автоматически освобождается, даже если при выполнении блока возникло исключение.</p>

<p>Как только закончится код, оформленный с отступами в <code>with</code> (аналогичные отступы в циклах или функциях), это будет означать, что контекст закончился, и Python автоматически закроет файл.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">file = open('languages.txt', 'r', encoding='utf-8')

for line in file:
    print(line)

file.close()              # ручное закрытие файла

print('Файл закрыт')</code></pre>

<p>можно переписать в виде:</p>

<pre><code class="language-python">with open('languages.txt', 'r', encoding='utf-8') as file:
    for line in file:
        print(line)
                          # автоматическое закрытие файла
print('Файл закрыт')</code></pre>

<p>Обратите внимание: при использовании менеджера контекста не требуется использовать метод <code>close()</code>.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/ebc24404-212c-49c4-9c0f-a292bc48f323/" width="49">   При работе с файлами желательно всегда использовать менеджер контекста. Это делает программу надежнее.</p>

<h2 style="text-align: center;">Примечания</h2>

<p><strong>Примечание 1.</strong> Подробнее о файловом методе <code>seek()</code> можно почитать в <a href="https://docs.python.org/3/library/io.html#io.TextIOBase.seek" rel="nofollow noopener noreferrer" target="_blank">документации</a>.</p>

<p><strong>Примечание 2. </strong>В современных операционных системах файловый ввод-вывод устроен достаточно сложно. Для обеспечения максимального быстродействия чтения и записи в файлы, а также контроля безопасности этого процесса, большинство операционных систем не позволяют программам напрямую работать с диском. Операционная система предоставляет программам специальные объекты — файловые дескрипторы (функция <code>open()</code> возвращает как раз файловый дескриптор). Имея файловый дескриптор, можно записывать и читать данные, не задумываясь о файловой системе. Файловые дескрипторы удобны, но на создание каждого расходуется достаточно большое количество ресурсов. Поэтому у операционной системы есть общий лимит на количество одновременно использующихся файловых дескрипторов. И при этом каждая программа имеет свой собственный лимит. Как только программа исчерпает доступное ей количество дескрипторов, следующая попытка открыть очередной файл закончится с ошибкой. Программисту важно следить за тем, сколько файлов программа открывает в каждый момент и закрывает ли она их своевременно. Используйте менеджер контекста <code>with</code> и жизнь станет проще 😋.</p>

<p><strong>Примечание 3.</strong> С помощью менеджера контекста можно работать с несколькими файлами.</p>

<pre><code class="language-python">with open('input.txt', 'r') as input_file, open('output.txt', 'w') as output_file:
    # обработка файлов</code></pre>

<h2 style="text-align: right;"><strong>Made with 💛 by BEEGEEK</strong></h2>