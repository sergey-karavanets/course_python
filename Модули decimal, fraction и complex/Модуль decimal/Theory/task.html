<h1>Тема урока: модуль decimal</h1>

<ol>
	<li>Числа с плавающей точкой <code>float</code></li>
	<li>Модуль <code>decimal</code></li>
	<li>Тип данных <code>Decimal</code></li>
</ol>

<p><strong>Аннотация.</strong> Урок посвящен модулю <code>decimal</code> и типу данных <code>Decimal</code>.</p>

<h2 style="text-align: center;">Числовые типы данных</h2>

<p>В прошлых уроках мы изучили два числовых типа данных, представленных в Python:</p>

<ul>
	<li><code>int</code> – целое число;</li>
	<li><code>float</code> – число с плавающей точкой (аналог вещественного числа в математике).</li>
</ul>

<p>В Python есть три дополнительных числовых типа данных:</p>

<ul>
	<li><code>Decimal</code> – десятичное число, для выполнения точных расчетов;</li>
	<li><code>Fraction</code> – число, представляющее собой <a href="https://ru.wikipedia.org/wiki/%D0%94%D1%80%D0%BE%D0%B1%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)#.D0.9E.D0.B1.D1.8B.D0.BA.D0.BD.D0.BE.D0.B2.D0.B5.D0.BD.D0.BD.D1.8B.D0.B5_.D0.B4.D1.80.D0.BE.D0.B1.D0.B8" rel="noopener noreferrer nofollow">обыкновенную дробь</a>, с заданным числителем и знаменателем;</li>
	<li><code>Complex</code> – комплексное число.</li>
</ul>

<p>В этом уроке мы изучим числовой тип данных <code>Decimal</code>, аналог типа данных <code>float</code> на случай более точных вычислений.</p>

<h2 style="text-align: center;">Тип данных float</h2>

<p>Рассмотрим программный код:</p>

<pre><code class="language-python">if 0.3 == 0.3:
    print('YES')
else:
    print('NO')</code></pre>

<p>Результатом выполнения такого кода будет как и полагается <code>YES</code>.</p>

<p>А теперь рассмотрим программный код:</p>

<pre><code class="language-python">num = 0.1 + 0.1 + 0.1

if num == 0.3:
    print('YES')
else:
    print('NO')</code></pre>

<p>Вы будете удивлены, но результатом выполнения такого кода будет <code>NO</code>, так как на самом деле в переменной <code>num</code> хранится что-то типа $0.30000000000000004$.</p>

<p>Из-за ограничений в сохранении точного значения чисел, даже простейшие математические операции могут выдавать ошибочный результат. Поэтому, чтобы сравнивать два <code>float</code> числа мы должны использовать такой код:</p>

<pre><code class="language-python">num = 0.1 + 0.1 + 0.1
eps = 0.000000001           # точность сравнения

if abs(num - 0.3) &lt; eps:    # число num отличается от числа 0.3 менее чем 0.000000001
    print('YES')
else:
    print('NO')</code></pre>

<p>Такой код выводит, как полагается, значение <code>YES</code>.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/5bb526d4-cb4b-4861-936a-1c35a1d4fe31/" style="float: left;" width="49">Не стоит сравнивать <code>float</code> числа с помощью оператора <code>==</code>. Для сравнения <code>float</code> чисел нужно использовать указанный выше код.</p>

<h2 style="text-align: center;">Тип данных Decimal</h2>

<p>Тип данных <code>Decimal</code> – это класс из стандартного модуля <code>decimal</code>. Он представляет собой число с плавающей точкой, как и <code>float</code>. Однако, <code>Decimal</code> имеет ряд существенных отличий от <code>float</code>.</p>

<p>Тип <code>Decimal</code> создан, чтобы операции над вещественными числами в компьютере выполнялись как в математике, и равенство $0.1 + 0.1 + 0.1 == 0.3$ было верным.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/af39ceca-dd75-4054-8765-09bdd53edf48/" style="float: left;" width="49">Точность результатов арифметических действий очень важна для научных вычислений, в сфере финансов и бизнеса. Для таких задач тип данных <code>float</code> не подходит.</p>

<p>В Python тип данных <code>float</code> реализован по стандарту IEEE-754 как число с плавающей точкой двойной точности ($64$ бита) с основанием экспоненты равным $2$. Реализация таких чисел заложена прямо в железо любого современного процессора. Поэтому <code>float</code> в Python работает как аналогичный тип данных <code>double</code> в таких языках программирования как С#, С++, Java и т.д. И имеет такие же ограничения и «странности». Так как <code>float</code> поддерживается аппаратно, быстродействие при использовании этого типа данных сравнительно велико.</p>

<p>Тип данных <code>Decimal</code> – число с плавающей точкой с основанием экспоненты $10$. Он реализован по стандарту IBM: General Decimal Arithmetic Specification, в свою очередь основанному на стандартах IEEE.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/7ef8d91c-86ad-4fe4-b07f-210ad5605376/" style="float: left;" width="49">Тип данных <code>Decimal</code> реализован программно, поэтому он в разы медленнее типа данных <code>float</code>, реализованного аппаратно. Сам тип данных <code>Decimal</code> написан на языке С.</p>

<p>Тип данных <code>Decimal</code> оперирует числами с произвольной – задаваемой программистом, но конечной точностью. По умолчанию точность составляет $28$ десятичных знаков.</p>

<p><img alt="" height="49" src="https://ucarecdn.com/181cce9f-1918-4dae-a4f7-2a69f15953b4/" style="float: left;" width="49">Тип данных <code>Decimal</code> неизменяемый. Операции над ним приводят к созданию новых объектов, при этом старые не меняются.</p>

<p>Еще одно следствие того, что <code>Decimal</code> реализован программно – его можно на ходу настраивать, как угодно программисту. Для этого есть контекст – объект, содержащий настройки для выполнения операций. Операции, выполняемые в контексте, следуют заданным в нем правилам. Для <code>float</code> все правила фиксированы на аппаратном уровне.</p>

<p>Для типа данных <code>Decimal</code> можно настроить:</p>

<ul>
	<li>точность выполнения операций в количестве десятичных знаков;</li>
	<li>режимы округления;</li>
	<li>режимы обработки исключительных ситуаций (деление на ноль, переполнение и т. д).</li>
</ul>

<h3 style="text-align: center;">Создание Decimal чисел</h3>

<p>Создать <code>Decimal</code> число можно из обычного целого числа (<code>int</code>), из числа с плавающей точкой (<code>float</code>) или из строки (<code>str</code>).</p>

<p>Приведенный ниже программный код создает <code>Decimal</code> числа на основе целого числа и строки:</p>

<pre><code class="language-python">from decimal import *

d1 = Decimal(1)
d2 = Decimal(567)
d3 = Decimal(-93)
d4 = Decimal('12345')
d5 = Decimal('52.198')

print(d1, d2, d3, d4, d5, sep='\n')</code></pre>

<p>и выводит:</p>

<pre><code class="language-no-highlight">1
567
-93
12345
52.198</code></pre>

<p>При создании <code>Decimal</code> чисел из чисел с плавающей точкой (<code>float</code>) возникают проблемы, так как <code>float</code> числа округляются внутри до ближайшего возможного, а <code>Decimal</code> об этом ничего не знает и копирует содержимое <code>float</code>.</p>

<p>Приведенный ниже программный код создает <code>Decimal</code> число на основе числа с плавающей точкой:</p>

<pre><code class="language-python">from decimal import *

num = Decimal(0.1)

print(num)</code></pre>

<p>и выводит:</p>

<pre><code class="language-no-highlight">0.1000000000000000055511151231257827021181583404541015625</code></pre>

<p><img alt="" height="49" src="https://ucarecdn.com/3e7b7509-26c9-47bd-bc88-c0f35aff5d19/" style="float: left;" width="49">Не рекомендуется создавать <code>Decimal</code> числа из <code>float</code> чисел. В <code>Decimal</code> попадет уже неправильно округленное число. Создавать <code>Decimal</code> числа нужно из целых чисел, либо из строк!</p>

<h3 style="text-align: center;"> Арифметические операции над Decimal числами</h3>

<p>Тип данных <code>Decimal</code> отлично интегрирован в язык Python. С <code>Decimal</code> числами работают все привычные операции: сложение, вычитание, умножение, деление, возведение в степень.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

num1 = Decimal('5.2')
num2 = Decimal('2.3')

print(num1 + num2)
print(num1 - num2)
print(num1 * num2)
print(num1 / num2)
print(num1 // num2)
print(num1 ** num2)</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">7.5
2.9
11.96
2.260869565217391304347826087
2
44.34122533787992500412791298</code></pre>

<p>Можно совершать арифметические операции над <code>Decimal</code> и целыми числами (миксовать <code>Decimal</code> и <code>int</code>), но не рекомендуется смешивать их с <code>float</code>.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

num = Decimal('5.2')

print(num + 1)
print(num - 10)
print(num * 2)
print(num ** 4)</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">6.2
-4.8
10.4
731.1616</code></pre>

<h3 style="text-align: center;">Математические функции</h3>

<p><code>Decimal</code> числа можно передавать как аргументы функциям, ожидающим <code>float</code>. Они будут преобразованы во <code>float</code>. К примеру, модуль <code>math</code>, оперирующий <code>float</code> числами, может работать и с <code>Decimal</code> числами.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *
from math import *

num1 = Decimal('1.44')
num2 = Decimal('0.523')

print(sqrt(num1))
print(sin(num2))
print(log(num1 + num2))</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">1.2
0.4994813555186418
0.6744739152943241</code></pre>

<p>Важно понимать, что результатом работы функции модуля <code>math</code> являются <code>float</code> числа, а не <code>Decimal</code>.</p>

<p>Тип данных <code>Decimal</code> содержит некоторые встроенные математические методы, возвращающие значения <code>Decimal</code>.</p>

<table align="center" border="1" cellpadding="1" cellspacing="1">
	<thead>
		<tr>
			<th>     Функция  </th>
			<th>Описание</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>sqrt()</code></td>
			<td>вычисляет квадратный корень из <code>Decimal</code> числа</td>
		</tr>
		<tr>
			<td><code>exp()</code></td>
			<td>
			<p>возвращает $e^x$ для <code>Decimal</code> числа</p>
			</td>
		</tr>
		<tr>
			<td><code>ln()</code></td>
			<td>
			<p>вычисляет натуральный логарифм (по основанию $e$) <code>Decimal</code> числа</p>
			</td>
		</tr>
		<tr>
			<td><code>log10()</code></td>
			<td>
			<p>вычисляет десятичный логарифм (по основанию $10$) <code>Decimal</code> числа</p>
			</td>
		</tr>
	</tbody>
</table>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

num = Decimal('10.0')

print(num.sqrt())
print(num.exp())
print(num.ln())
print(num.log10())</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">3.162277660168379331998893544
22026.46579480671651695790065
2.302585092994045684017991455
1</code></pre>

<p><img alt="" height="49" src="https://ucarecdn.com/2ff98855-3224-4e0b-b3b7-9a219db448f7/" style="float: left;" width="49">Обратите внимание на количество знаков после запятой. Их $28$, что соответствует точности десятичного числа по умолчанию.</p>

<p>Тип данных <code>Decimal</code> также содержит полезный метод <code>as_tuple()</code> который возвращает кортеж из $3$ элементов:</p>

<ul>
	<li><code>sign</code> – знак числа ($0$ для положительного числа и $1$ для отрицательного числа);</li>
	<li><code>digits</code> – цифры числа;</li>
	<li><code>exponent</code> – значение экспоненты (количество цифр после точки, умноженное на $-1$),</li>
</ul>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

num1 = Decimal('-1.4568769017')
num2 = Decimal('0.523')

print(num1.as_tuple())
print(num2.as_tuple())</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">DecimalTuple(sign=1, digits=(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7), exponent=-10)
DecimalTuple(sign=0, digits=(5, 2, 3), exponent=-3)</code></pre>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

num = Decimal('-1.4568769017')
num_tuple = num.as_tuple()

print(num_tuple.sign)
print(num_tuple.digits)
print(num_tuple.exponent)</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">1
(1, 4, 5, 6, 8, 7, 6, 9, 0, 1, 7)
-10</code></pre>

<h3 style="text-align: center;">Работа с контекстом Decimal чисел</h3>

<p>Базовые параметры <code>Decimal</code> можно посмотреть в его <strong>контексте</strong>, выполнив функцию <code>getcontext()</code>.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

print(getcontext())</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, 
flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])</code></pre>

<p>Мы видим здесь, что точность $28$ знаков, округление к ближайшему четному, пределы по экспоненте $\pm 999999$, <code>capitals</code> – это про заглавную Е при печати, включенные ловушки – неправильная операция, деление на ноль, переполнение.</p>

<h3 style="text-align: center;">Точность чисел</h3>

<p>Контекстом в <code>Decimal</code> можно управлять, устанавливая свои значения. Например, чтобы управлять точностью <code>Decimal</code>, необходимо изменить параметр контекста <code>prec</code> (от англ. precision – точность). При этом точность вступает в силу только во время арифметических операций, а не при создании самих чисел.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

getcontext().prec = 3      # устанавливаем точность в 3 знака

num = Decimal('3.1415')

print(num)
print(num * 1)
print(num * 2)
print(num / 2)</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">3.1415
3.14
6.28
1.57</code></pre>

<p><img alt="" height="49" src="https://ucarecdn.com/b82d90b3-1325-469b-980a-787707decc8f/" style="float: left;" width="49">Обратите внимание на то, что точность вступает в силу только во время арифметических операций, а не при создании самих чисел.</p>

<h3 style="text-align: center;">Округление чисел</h3>

<p>Округляют числа <code>Decimal</code> с помощью метода <code>quantize()</code>. Этот метод в качестве первого аргумента принимает объект <code>Decimal</code>, указывающий на формат округления.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

getcontext().prec = 4                    # устанавливаем точность числа

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.000')))    #  округление до 3 цифр в дробной части  
print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части
print(num.quantize(Decimal('1.0')))      #  округление до 1 цифр в дробной части</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">3.142
3.14
3.1</code></pre>

<p>Если точность округления установлена в $2$ , а формат округления <code>Decimal('1.00')</code>, то возникнет ошибка.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

getcontext().prec = 2                    # устанавливаем точность округления

num = Decimal('3.1415926535')

print(num.quantize(Decimal('1.00')))     #  округление до 2 цифр в дробной части</code></pre>

<p>приводит к возникновению ошибки:</p>

<pre><code class="language-1c">decimal.InvalidOperation: [&lt;class 'decimal.InvalidOperation'&gt;]</code></pre>

<p>Чтобы избежать ее, необходимо поменять точность округления на $3$ и больше.</p>

<p>Помимо первого параметра, метод <code>quantize()</code> принимает в качестве второго параметра стратегию округления:</p>

<ul>
	<li><code>ROUND_CEILING</code> – округление в направлении бесконечности (Infinity);</li>
	<li><code>ROUND_FLOOR</code> – округляет в направлении минус бесконечности (- Infinity);</li>
	<li><code>ROUND_DOWN</code> – округление в направлении нуля;</li>
	<li><code>ROUND_HALF_EVEN</code> – округление до ближайшего четного числа, число $6.9$ округлится не до $7$, а до $6$;</li>
	<li><code>ROUND_HALF_DOWN</code> – округление до ближайшего нуля;</li>
	<li><code>ROUND_UP</code> – округление от нуля;</li>
	<li><code>ROUND_05UP</code> – округление от нуля (если последняя цифра после округления до нуля была бы 0 или 5, в противном случае к нулю).</li>
</ul>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

num = Decimal('3.456')

print(num.quantize(Decimal('1.00'), ROUND_CEILING))
print(num.quantize(Decimal('1.00'), ROUND_FLOOR))</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">3.46
3.45</code></pre>

<h3 style="text-align: center;">Сравнение float и Decimal чисел</h3>

<p>Выбор между типами данных <code>Decimal</code> и <code>float</code> – поиск компромисса в условиях конкретной задачи.</p>

<p>Если нужно считать очень много (симуляции, физика, графика, игры), имеет смысл отказаться от точности <code>Decimal</code> в пользу скорости и компактности хранения данных <code>float</code>. В бизнесе и финансах считать приходится не так много, но делать это нужно предельно точно, тут имеет смысл посмотреть в сторону <code>Decimal</code>.</p>

<table align="center" border="1" cellpadding="1" cellspacing="1">
	<tbody>
		<tr>
			<td style="text-align: center;"><strong>Характеристика / тип</strong></td>
			<td style="text-align: center;"><strong>float</strong></td>
			<td style="text-align: center;"><strong>Decimal</strong></td>
		</tr>
		<tr>
			<td>Реализация</td>
			<td style="text-align: center;">аппаратная</td>
			<td style="text-align: center;">программная</td>
		</tr>
		<tr>
			<td>Размер</td>
			<td style="text-align: center;">$64$ бит</td>
			<td style="text-align: center;">не ограничен</td>
		</tr>
		<tr>
			<td>Основание экспоненты</td>
			<td style="text-align: center;">$2$</td>
			<td style="text-align: center;">$10$</td>
		</tr>
		<tr>
			<td>Скорость</td>
			<td style="text-align: center;">✔️</td>
			<td style="text-align: center;">❌</td>
		</tr>
		<tr>
			<td>Настраиваемость</td>
			<td style="text-align: center;">❌</td>
			<td style="text-align: center;">✔️</td>
		</tr>
		<tr>
			<td>Для финансов и бизнеса</td>
			<td style="text-align: center;">❌</td>
			<td style="text-align: center;">✔️</td>
		</tr>
		<tr>
			<td>Для симуляций, визуализаций и игр</td>
			<td style="text-align: center;">✔️</td>
			<td style="text-align: center;">❌</td>
		</tr>
		<tr>
			<td>Для высокоточных вычислений</td>
			<td style="text-align: center;">❌</td>
			<td style="text-align: center;">✔️</td>
		</tr>
	</tbody>
</table>

<h2 style="text-align: center;">Примечания</h2>

<p><strong>Примечание 1.</strong> <code>Decimal</code> числа можно сравнивать между собой, как обычные числа, причем в отличие от <code>float</code> чисел допускается и точное равенство.</p>

<pre><code class="language-python">from decimal import *

num = Decimal('0.1')
if num*3 == Decimal('0.3'):
    print('YES')
else:
    print('NO')</code></pre>

<p><strong>Примечание 2.</strong> Можно сортировать списки с <code>Decimal</code> числами и искать минимум и максимум среди них.</p>

<p>Приведенный ниже код:</p>

<pre><code class="language-python">from decimal import *

s = '1.34 3.45 1.00 0.03 9.25'

numbers = [Decimal(i) for i in s.split()]

maximum = max(numbers)
minimum = min(numbers)

numbers.sort()

print(maximum)
print(minimum)
print(numbers)</code></pre>

<p>выводит:</p>

<pre><code class="language-no-highlight">9.25
0.03
[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('3.45'), Decimal('9.25')]</code></pre>

<p><strong>Примечание 3.</strong> Подробнее о типе данных Decimal можно почитать в официальной документации <a href="https://docs.python.org/3.8/library/decimal.html" rel="noopener noreferrer nofollow">тут</a>, <a href="https://docs.python.org/3.8/library/decimal.html#decimal-objects" rel="noopener noreferrer nofollow">тут</a> и <a href="https://www.python.org/dev/peps/pep-0327/" rel="noopener noreferrer nofollow">тут</a>.</p>

<p><strong>Примечание 4.</strong> Подробная статья об устройстве <code>float</code> чисел на <a href="https://habr.com/post/112953/" rel="noopener noreferrer nofollow">хабре</a>.</p>

<p><strong>Примечание 5.</strong> О стандарте <code>Decimal</code> чисел от IBM можно почитать <a href="http://speleotrove.com/decimal/decarith.html" rel="noopener noreferrer nofollow">тут</a>.</p>

<p><strong>Примечание 6.</strong> Чтобы не писать каждый раз название типа, можно использовать следующий код:</p>

<pre><code class="language-python">from decimal import Decimal as D

num1 = D('1.5') + D('3.2')
num2 = D('1.4') * D('2.58')

print(num1)
print(num2)</code></pre>

<h2 style="text-align: right;"><strong>Made with 💛 by BEEGEEK</strong> </h2>